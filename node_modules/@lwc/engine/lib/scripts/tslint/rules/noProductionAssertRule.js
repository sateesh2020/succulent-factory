"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const ts = __importStar(require("typescript"));
const Lint = __importStar(require("tslint"));
class Rule extends Lint.Rules.AbstractRule {
    apply(sourceFile) {
        return this.applyWithFunction(sourceFile, walk);
    }
}
Rule.metadata = {
    ruleName: 'no-production-assert',
    description: 'Avoid leaking asserts into production code.',
    rationale: Lint.Utils.dedent `
            We should strip asserts when compiling the framework code for production environment.
            For that the assertion code should be wrapped in: if (process.env.NODE_ENV !== 'production') {}.
        `,
    hasFix: false,
    type: 'functionality',
    options: {},
    optionsDescription: 'No options.',
    typescriptOnly: true,
};
Rule.FAILURE_STRING = "No asserts allowed in production, wrap in a condition: if (process.env.NODE_ENV === 'production') {}";
exports.Rule = Rule;
function walk(ctx) {
    function cb(node) {
        if (node.kind === ts.SyntaxKind.IfStatement) {
            const ifnode = node;
            if (ifnode.expression.getText() === "process.env.NODE_ENV !== 'production'") {
                if (ifnode.elseStatement) {
                    // we need to look for asserts in the else statement.
                    return ts.forEachChild(ifnode.elseStatement, cb);
                }
            }
            else {
                // we need to analyze this node.
                return ts.forEachChild(node, cb);
            }
        }
        else if (node.kind === ts.SyntaxKind.PropertyAccessExpression) {
            const isUsingAssert = node.getText().startsWith('assert.')
                && node.parent && node.parent.kind === ts.SyntaxKind.CallExpression;
            if (isUsingAssert) {
                ctx.addFailureAtNode(node, Rule.FAILURE_STRING);
            }
        }
        else {
            return ts.forEachChild(node, cb);
        }
    }
    return ts.forEachChild(ctx.sourceFile, cb);
}
//# sourceMappingURL=noProductionAssertRule.js.map