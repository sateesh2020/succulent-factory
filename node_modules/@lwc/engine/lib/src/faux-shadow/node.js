"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const language_1 = require("../shared/language");
const node_1 = require("../env/node");
const window_1 = require("../env/window");
const element_1 = require("../env/element");
const traverse_1 = require("./traverse");
const text_content_1 = require("../3rdparty/polymer/text-content");
const shadow_root_1 = require("./shadow-root");
// DO NOT CHANGE this:
// these two values need to be in sync with framework/vm.ts
const OwnerKey = '$$OwnerKey$$';
const OwnKey = '$$OwnKey$$';
exports.hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';
function getNodeOwnerKey(node) {
    return node[OwnerKey];
}
exports.getNodeOwnerKey = getNodeOwnerKey;
function setNodeOwnerKey(node, key) {
    node[OwnerKey] = key;
}
exports.setNodeOwnerKey = setNodeOwnerKey;
function getNodeNearestOwnerKey(node) {
    let ownerNode = node;
    let ownerKey;
    // search for the first element with owner identity (just in case of manually inserted elements)
    while (!language_1.isNull(ownerNode)) {
        ownerKey = ownerNode[OwnerKey];
        if (!language_1.isUndefined(ownerKey)) {
            return ownerKey;
        }
        ownerNode = node_1.parentNodeGetter.call(ownerNode);
    }
}
exports.getNodeNearestOwnerKey = getNodeNearestOwnerKey;
function getNodeKey(node) {
    return node[OwnKey];
}
exports.getNodeKey = getNodeKey;
const portals = new WeakMap();
// We can use a single observer without having to worry about leaking because
// "Registered observers in a nodeâ€™s registered observer list have a weak
// reference to the node."
// https://dom.spec.whatwg.org/#garbage-collection
let portalObserver;
const portalObserverConfig = {
    childList: true,
    subtree: true,
};
function patchPortalElement(node, ownerKey, shadowToken) {
    // If node already has an ownerKey, we can skip
    // Note: checking if a node as any ownerKey is not enough
    // because this element could be moved from one
    // shadow to another
    if (getNodeOwnerKey(node) === ownerKey) {
        return;
    }
    setNodeOwnerKey(node, ownerKey);
    if (node instanceof Element) {
        setCSSToken(node, shadowToken);
        const childNodes = exports.getInternalChildNodes(node);
        for (let i = 0, len = childNodes.length; i < len; i += 1) {
            const child = childNodes[i];
            patchPortalElement(child, ownerKey, shadowToken);
        }
    }
}
function initPortalObserver() {
    return new window_1.MutationObserver(mutations => {
        language_1.forEach.call(mutations, mutation => {
            const { target: elm, addedNodes } = mutation;
            const ownerKey = getNodeOwnerKey(elm);
            const shadowToken = getCSSToken(elm);
            // OwnerKey might be undefined at this point.
            // We used to throw an error here, but we need to return early instead.
            //
            // This routine results in a mutation target that will have no key
            // because its been removed by the time the observer runs
            // const div = document.createElement('div');
            // div.innerHTML = '<span>span</span>';
            // const span = div.querySelector('span');
            // manualElement.appendChild(div);
            // span.textContent = '';
            // span.parentNode.removeChild(span);
            if (language_1.isUndefined(ownerKey)) {
                return;
            }
            for (let i = 0, len = addedNodes.length; i < len; i += 1) {
                const node = addedNodes[i];
                patchPortalElement(node, ownerKey, shadowToken);
            }
        });
    });
}
const ShadowTokenKey = '$$ShadowTokenKey$$';
function setCSSToken(elm, shadowToken) {
    if (!language_1.isUndefined(shadowToken)) {
        element_1.setAttribute.call(elm, shadowToken, '');
        elm[ShadowTokenKey] = shadowToken;
    }
}
exports.setCSSToken = setCSSToken;
function getCSSToken(elm) {
    return elm[ShadowTokenKey];
}
function markElementAsPortal(elm) {
    portals.set(elm, 1);
    if (!portalObserver) {
        portalObserver = initPortalObserver();
    }
    // install mutation observer for portals
    window_1.MutationObserverObserve.call(portalObserver, elm, portalObserverConfig);
}
exports.markElementAsPortal = markElementAsPortal;
function isPortalElement(elm) {
    return portals.has(elm);
}
exports.isPortalElement = isPortalElement;
function getShadowParent(node, value) {
    const owner = traverse_1.getNodeOwner(node);
    if (value === owner) {
        // walking up via parent chain might end up in the shadow root element
        return shadow_root_1.getShadowRoot(owner);
    }
    else if (value instanceof Element) {
        if (getNodeNearestOwnerKey(node) === getNodeNearestOwnerKey(value)) {
            // the element and its parent node belong to the same shadow root
            return value;
        }
        else if (!language_1.isNull(owner) && traverse_1.isSlotElement(value)) {
            // slotted elements must be top level childNodes of the slot element
            // where they slotted into, but its shadowed parent is always the
            // owner of the slot.
            const slotOwner = traverse_1.getNodeOwner(value);
            if (!language_1.isNull(slotOwner) && traverse_1.isNodeOwnedBy(owner, slotOwner)) {
                // it is a slotted element, and therefore its parent is always going to be the host of the slot
                return slotOwner;
            }
        }
    }
    return null;
}
function PatchedNode(node) {
    const Ctor = language_1.getPrototypeOf(node).constructor;
    class PatchedNodeClass {
        constructor() {
            // Patched classes are not supposed to be instantiated directly, ever!
            throw new TypeError('Illegal constructor');
        }
        hasChildNodes() {
            return exports.getInternalChildNodes(this).length > 0;
        }
        // @ts-ignore until ts@3.x
        get firstChild() {
            const childNodes = exports.getInternalChildNodes(this);
            // @ts-ignore until ts@3.x
            return childNodes[0] || null;
        }
        // @ts-ignore until ts@3.x
        get lastChild() {
            const childNodes = exports.getInternalChildNodes(this);
            // @ts-ignore until ts@3.x
            return childNodes[childNodes.length - 1] || null;
        }
        get textContent() {
            return text_content_1.getTextContent(this);
        }
        set textContent(value) {
            node_1.textContextSetter.call(this, value);
        }
        get childElementCount() {
            return this.children.length;
        }
        get firstElementChild() {
            return this.children[0] || null;
        }
        get lastElementChild() {
            const { children } = this;
            return children.item(children.length - 1) || null;
        }
        get assignedSlot() {
            const parentNode = node_1.parentNodeGetter.call(this);
            /**
             * if it doesn't have a parent node,
             * or the parent is not an slot element
             * or they both belong to the same template (default content)
             * we should assume that it is not slotted
             */
            if (language_1.isNull(parentNode) || !traverse_1.isSlotElement(parentNode) || getNodeNearestOwnerKey(parentNode) === getNodeNearestOwnerKey(this)) {
                return null;
            }
            return parentNode;
        }
        get parentNode() {
            const value = node_1.parentNodeGetter.call(this);
            if (language_1.isNull(value)) {
                return value;
            }
            return getShadowParent(this, value);
        }
        get parentElement() {
            const value = node_1.parentNodeGetter.call(this);
            if (language_1.isNull(value)) {
                return null;
            }
            const parentNode = getShadowParent(this, value);
            // it could be that the parentNode is the shadowRoot, in which case
            // we need to return null.
            return parentNode instanceof Element ? parentNode : null;
        }
        getRootNode(options) {
            return traverse_1.getRootNodeGetter.call(this, options);
        }
        compareDocumentPosition(otherNode) {
            if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
                // it is from another shadow
                return 0;
            }
            return node_1.compareDocumentPosition.call(this, otherNode);
        }
        contains(otherNode) {
            if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
                // it is from another shadow
                return false;
            }
            return (node_1.compareDocumentPosition.call(this, otherNode) & node_1.DOCUMENT_POSITION_CONTAINED_BY) !== 0;
        }
        cloneNode(deep) {
            const clone = node_1.cloneNode.call(this, false);
            // Per spec, browsers only care about truthy values
            // Not strict true or false
            if (!deep) {
                return clone;
            }
            const childNodes = exports.getInternalChildNodes(this);
            for (let i = 0, len = childNodes.length; i < len; i += 1) {
                clone.appendChild(childNodes[i].cloneNode(true));
            }
            return clone;
        }
    }
    // prototype inheritance dance
    language_1.setPrototypeOf(PatchedNodeClass, Ctor);
    language_1.setPrototypeOf(PatchedNodeClass.prototype, Ctor.prototype);
    return PatchedNodeClass;
}
exports.PatchedNode = PatchedNode;
let internalChildNodeAccessorFlag = false;
/**
 * These 2 methods are providing a machinery to understand who is accessing the
 * .childNodes member property of a node. If it is used from inside the synthetic shadow
 * or from an external invoker. This helps to produce the right output in one very peculiar
 * case, the IE11 debugging comment for shadowRoot representation on the devtool.
 */
function isExternalChildNodeAccessorFlagOn() {
    return !internalChildNodeAccessorFlag;
}
exports.isExternalChildNodeAccessorFlagOn = isExternalChildNodeAccessorFlagOn;
exports.getInternalChildNodes = (process.env.NODE_ENV !== 'production' && language_1.isFalse(exports.hasNativeSymbolsSupport)) ?
    function (node) {
        internalChildNodeAccessorFlag = true;
        let childNodes;
        let error = null;
        try {
            childNodes = node.childNodes;
        }
        catch (e) {
            // childNodes accessor should never throw, but just in case!
            error = e;
        }
        finally {
            internalChildNodeAccessorFlag = false;
            if (!language_1.isNull(error)) {
                // re-throwing after restoring the state machinery for setInternalChildNodeAccessorFlag
                throw error; // tslint:disable-line
            }
        }
        return childNodes;
    } : function (node) {
    return node.childNodes;
};
//# sourceMappingURL=node.js.map